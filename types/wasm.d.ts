export function loadSVM(): Promise<{
    new (options: {
        type?: number;
        kernel?: number;
        degree?: number;
        gamma?: number;
        coef0?: number;
        cost?: number;
        nu?: number;
        epsilon?: number;
        cacheSize?: number;
        tolerance?: number;
        shrinking?: boolean;
        probabilityEstimates?: boolean;
        weight?: object;
        quiet?: boolean;
    }): {
        options: {
            type?: number;
            kernel?: number;
            degree?: number;
            gamma?: number;
            coef0?: number;
            cost?: number;
            nu?: number;
            epsilon?: number;
            cacheSize?: number;
            tolerance?: number;
            shrinking?: boolean;
            probabilityEstimates?: boolean;
            weight?: object;
            quiet?: boolean;
        };
        model: any;
        train(samples: Array<Array<number>>, labels: Array<number>): void;
        problem: any;
        crossValidation(samples: Array<Array<number>>, labels: Array<number>, kFold: number): Array<number>;
        free(): void;
        getCommand(samples: any): string;
        predictOne(sample: Array<number>): number;
        predict(samples: Array<Array<number>>): Array<number>;
        predictProbability(samples: Array<Array<number>>): Array<object>;
        predictOneProbability(sample: Array<number>): object;
        predictOneInterval(sample: Array<number>, confidence: number): object;
        predictInterval(samples: Array<Array<number>>, confidence: number): Array<object>;
        _getInterval(confidence: any): number;
        getLabels(): Array<number>;
        getSVIndices(): Array<number>;
        serializeModel(): string;
    };
    load(serializedModel: string): {
        options: {
            type?: number;
            kernel?: number;
            degree?: number;
            gamma?: number;
            coef0?: number;
            cost?: number;
            nu?: number;
            epsilon?: number;
            cacheSize?: number;
            tolerance?: number;
            shrinking?: boolean;
            probabilityEstimates?: boolean;
            weight?: object;
            quiet?: boolean;
        };
        model: any;
        train(samples: Array<Array<number>>, labels: Array<number>): void;
        problem: any;
        crossValidation(samples: Array<Array<number>>, labels: Array<number>, kFold: number): Array<number>;
        free(): void;
        getCommand(samples: any): string;
        predictOne(sample: Array<number>): number;
        predict(samples: Array<Array<number>>): Array<number>;
        predictProbability(samples: Array<Array<number>>): Array<object>;
        predictOneProbability(sample: Array<number>): object;
        predictOneInterval(sample: Array<number>, confidence: number): object;
        predictInterval(samples: Array<Array<number>>, confidence: number): Array<object>;
        _getInterval(confidence: any): number;
        getLabels(): Array<number>;
        getSVIndices(): Array<number>;
        serializeModel(): string;
    };
    SVM_TYPES: {
        C_SVC: string;
        NU_SVC: string;
        ONE_CLASS: string;
        EPSILON_SVR: string;
        NU_SVR: string;
    };
    KERNEL_TYPES: {
        LINEAR: string;
        POLYNOMIAL: string;
        RBF: string;
        SIGMOID: string;
        PRECOMPUTED: string;
    };
}>;
